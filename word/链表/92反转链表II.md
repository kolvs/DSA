#### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

给你单链表的头指针 head 和两个整数left 和 right ，其中left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。

**示例1:**

![](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)

**示例2:**

```
输入：head = [5], left = 1, right = 1
输出：[5]
```

---

解法一: 穿针引线-头插法

9 → 7 → 2 → 5 → 4 → 3 → 6

算法:

```
第1步: 将节点5插入节点2前面
9 → 7 → 2 → 5 → 4 → 3 → 6

第2步: 将节点4插入节点5前面
9 → 7 → 5 → 2 → 4 → 3 → 6

第3步: 将节点3插入节点4前面
9 → 7 → 4 → 5 → 2 → 3 → 6

完成
9 → 7 → 3 → 4 → 5 → 2 → 6
```

```Java
class Solution {
    public SingleNode reverseBetween(SingleNode head, int left, int right) {
        SingleNode dummyNode = new SingleNode(-1);
        dummyNode.next = head;
        SingleNode pre = dummyNode;
        for (int i = 0; i < left - 1; i++) {
            pre = pre.next;
        }
        SingleNode curr = pre.next;
        SingleNode next;
        for (int i = 0; i < right - left; i++) {
            next = curr.next;// curr的下一个节点记录为next
            curr.next = next.next;// curr的下一个节点指向next的下一个节点
            next.next = pre.next;// next的下一个节点指向pre的下一个节点
            pre.next = next;//pre的下一个节点指向next
        }
        return dummyNode.next;
    }
}
```

*时间复杂度: O(N), N为链表长度*

*空间复杂度: O(1)*

